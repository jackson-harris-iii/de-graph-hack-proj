//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.4;
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

contract DynamicCarbonOffsetNFT is
    ERC721,
    ERC721URIStorage,
    ERC721Enumerable,
    Ownable,
    KeeperCompatibleInterface,
    ChainlinkClient, 
    ConfirmedOwner
{
    using Strings for uint256;
    using Counters for Counters.Counter;
    using Chainlink for Chainlink.Request;
    
    Counters.Counter private _tokenIds;
    
    bytes32 private jobId;
    uint256 private fee;

    struct DCON {
        address owner;
        string tokenURI;
        uint256 tokenId;
    }

    /*

  --- tokenURI Shape in ipfs ---
    string name
    string description 
    string category
    string categoryImage
    uint256 totalCarbonOffset; //measured in tons
    uint256 totalCarbonFootprint;
    string country;
    uint256 countryEmmissionsTotal;
    uint256 countryEmmissionsPerCapita;

  */

    event NewDCON_NFT_Minted(
          address indexed sender,
          uint256 indexed newItemId,
          string ipfsURI
        );

    event WiltRequest(bytes32 indexed requestId, address indexed sender,string ipfsURI);    

    uint256 public tokenCounter;
    mapping(uint256 => DCON) public DCONS_mapping;

    // keeper variables
    uint256 interval;
    uint256 lastTimeStamp;

    constructor(uint256 _interval) ERC721("Dynamic Carbon Offset NFT", "DCON") {
        tokenCounter = 0;
        interval = _interval;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            wiltNFT();
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function mintDCON(string memory ipfsURI) public {
        uint256 newItemId = _tokenIds.current();

        DCON memory newDCON = DCON({
          owner: msg.sender;
          tokenURI: ipfsURI;
          tokenId: newItemId;
        })
        DCONS_mapping[newItemId + 1] = DCON
        _safeMint(msg.sender, newItemId);

        //Update URI !!!
        _setTokenURI(newItemId, ipfsURI);

        _tokensIds.increment();

        emit NewDCON_NFT_Minted(
          msg.sender,
          newItemId,
          ipfsURI
        )
    }

    function _setTokenURI(uint256 _tokenId, string memory _tokenURI)
        internal
        virtual
    {
        require(
            _exists(_tokenId),
            "ERC721Metadata: URI set of nonexistent token"
        ); // Checks if the tokenId exists
        _tokenURIs[_tokenId] = _tokenURI;
    }

    function tokenURI(uint256 _tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(_tokenId),
            "ERC721Metadata: URI set of nonexistent token"
        );
        return _tokenURIs[_tokenId];
    }

    function wiltNFT(uint256 _tokenId) {

    }
}
